# n-grams-for-synthesis, attempt #3 (at least!)

n-gram probabilities based on Scheme/Racket code, for directing search of the relational Scheme interpreter, and a prototype example relational interpreter with a search informed by these probabilities.

The ideas explored in this repo are inspired by conversations and hacking sessions that included: Rob Zinkov, Michael Ballantyne, Will Byrd, Greg Rosenblatt, Evan Donahue, Ramana Kumar, Nehal Patel, attendees of the Advanced miniKanren Hangout series, and members of the broader miniKanren community.  Early hacking to extract poatterns from Clojure code was done by Micahel Ballantyne and Will Byrd, with critical guidance from Rob Zinkov (see https://github.com/webyrd/rnn-clojure).  Will hacked up a crude, somewhat broken version of the system in the `old_code/original_version` directory.  This was improved by "mob programming" during miniKanren advanced hangouts #6 and #7 (see https://github.com/webyrd/miniKanren-hangout-summaries and https://github.com/webyrd/miniKanren-hangout-summaries/tree/master/code/advanced-hangouts)--the final improved code can be found in `old_code/advanced_hangout_7_version`.  The code in `old_code/advanced_hangout_7_version/interp-fastest-fixed-application-optimization.scm` benefits from Greg's optimization for variable-argument application, inspired by his work on Barliman (https://github.com/webyrd/Barliman).  This version also includes some nice abstractions to avoid duplicate code.  The interpreter (and several previous versions) does include a "cheat" in the application cases: "Cheat a little by requring the rator expression to be a variable reference. Note that this prevents us from synthesizing code like `(((lambda (x) x) (lambda (x) x)) '(1 2 3))`."

This latest attempt at n-gram-based guided search was inspired by Rob Zinkov hosting Will Byrd at University of Oxford in January of 02018.  Rob has been hacking on getting a larger corpus of trainign programs, while Will has been working on how to better integrate the resulting probabilities into the relational interpreters.

Many thanks to everyone who has helped improve the ideas and code!

TODO

Benchmarks for fairly comparing Barliman interpreter with optimizations, the vanilla full interpreter, and full interpreters with guided search.   Complications: beware of `boolean-conditions-only?` and `allow-incomplete-search?` flags in the Barliman interpreter, the `enable-conde1?` flag in `mk/mk.scm` of the Barliman mk implementation, and the application "cheat" in the `old_code/advanced_hangout_7_version/interp-fastest-fixed-application-optimization.scm` interpreter. Also, the full Barliman interpreter includes other optimizations not included in the `old_code/advanced_hangout_7_version/interp-fastest-fixed-application-optimization.scm` interpreter.  And the `mk.scm` file used by Barliman includes `state-deferred-defer*` and other code that the `mk.scm` in `old_code/advanced_hangout_7_version/` doesn't have.  Need to make sure we are doing a fair comparison!