This directory contains several versions of the 'full-interp.scm' relational interpreter from 'faster-mk' (https://github.com/michaelballantyne/faster-miniKanren/blob/master/full-interp.scm), along with the implementation of 'faster-mk'.  The modified versions of the interpreter are intended to explore the tradeoffs in ordering the 'conde' clauses in the interpreter by the context of the current expression to be evaluated or synthesized (for example, if the current context is the body of a 'lambda' expression, then perhaps an 'if' expression would be likely.

The intent is to order the 'conde' clauses based on the bigram results in the main directory.

The interpreters, in the order I modified them:

* interp-old-style.scm -- the original relational interpreter from the 'faster-mk' repository, corresponding to https://github.com/michaelballantyne/faster-miniKanren/blob/master/full-interp.scm   There is one, fixed ordering of 'conde' clauses in this interpreter, and the interpreter does not pass around the context of the current expression.
* interp-inlined-prims.scm -- same as 'interp-old-style.scm', except that all primitives have been "inlined" into the main 'conde' of 'eval-expo'.  There is one, fixed ordering of 'conde' clauses in this interpreter, and the interpreter does not pass around the context of the current expression.  The intent of this interpreter is to prepare for the next transformation (dummy evalo dispatch), and to be able to benchmark the effect of inlining primitives without reording the clauses.  This interpreter appears significantly slower than 'interp-old-style.scm' on most or all of the benchmarks.
* interp-inlined-prims-with-dummy-evalo-dispatch.scm -- same as 'interp-inlined-prims.scm', except that 'eval-expo' has been replaced by 'make-eval-expo', which dispatches to a function that performs the work of the old 'eval-expo' based on the context of the current expression.  This is a "dummy" dispatch: the dispatch tests are made, but there is only one function with a fixed 'conde' ordering that is always dispatched to.  The intent of this interpreter is to prepare for the next transformation (interp-inlined-prims-with-real-evalo-dispatch), and to be able to benchmark the effect of dispatch to a helper function containing the main 'conde' for the interpreter.
* interp-inlined-prims-with-real-evalo-dispatch.scm -- same as 'interp-inlined-prims.scm', except that 'make-eval-expo' now makes a choice between different helper functions with different 'conde' orderings, based on the context of the current expression.  For almost all contexts the interpreter dispatches to 'eval-expo-with-default-ordering', which uses the same goal ordering of 'interp-inlined-prims.scm' (which in turn is based on the goal ordering of 'interp-old-style.scm'.  However, this interpreter dispatches to 'eval-expo-if-test-ordering' when the current expression is the test of an 'if' expression, and this change alone appears to radically speed up some of the benchmarks without harming the other benchmarks noticably.  For example, test "append-10" went from taking ~30 seconds to taking ~40 milliseconds.

To run these tests, and see the timings of the benchmarks, load the appropriate test file in Chez Scheme.  The most interesting contrast is between 'test-interp-old-style.scm' and 'test-interp-inlined-prims-with-real-evalo-dispatch.scm', especially in synthesis tests such as 'append-9', 'append-10', and 'append-11'.  (Some of these tests are commented out in interpreters other than 'interp-inlined-prims-with-real-evalo-dispatch.scm'.  This is because the tests did not return after I ran them for a while (30 seconds or more).)

The interpreter 'interp-fastest.scm' is a "less dumb" version of 'interp-inlined-prims-with-real-evalo-dispatch.scm' that makes obvious optimizations (such as multi-argument application should come before variadic application, even though the n-grams program does not yet gather this information).
